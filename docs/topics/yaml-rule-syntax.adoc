// Module included in the following assemblies:
//
// * docs/rules-development-guide/master.adoc

:_content-type: REFERENCE
[id="yaml-rule-syntax_{context}"]
= Analyzer rules

Each analyzer rule is a set of instructions that are used to analyze source code and detect issues that are problematic for migration.

The analyzer parses user-provided rules, applies them to applications' source code, and generates issues for matched rules. A collection of one or more rules forms a ruleset. Creating rulesets provides a way of organizing multiple rules that achieve a common goal. The analyzer CLI takes rulesets as input arguments.

[id="yaml-rule-structure_{context}"]
== YAML rule structure

Rules are written in YAML. Each rule consists of metadata, conditions and actions. It instructs the analyzer to take specified actions when given conditions match.

[id="yaml-rule-metadata_{context}"]
=== Metadata

Rule metadata contains general information about the rule. The structure of metadata is as follows.

[source,terminal]
----
ruleId: "unique_id" <1>
# issues have pre-defined categories
category: "potential|information|mandatory"
labels: <2>
  # key=value pair
  - "label1=val1"
  # valid label with value omitted
  - "label2"
  # valid label with empty value
  - "label3="
  # subdomain prefixed key
  - "konveyor.io/label1=val1"
effort: 1 <3>
----
<1> The id must be unique within the ruleset to which the rule belongs

<2> See below for a description of the label format.

<3> Effort is an integer value that indicates the level of effort needed to fix this issue.

[id="yaml-rule-labels_{context}"]
==== Labels

Labels are `key=val` pairs specified for rules or rulesets as well as dependencies. For dependencies, a provider adds the labels to the dependencies when retrieving them. Labels on a ruleset are automatically inherited by all the rules that belong to it.

.Label format

Labels are specified under the `labels` field as a list of strings in `key=val` format as follows:

[source,terminal]
----
labels:
- "key1=val1"
- "key2=val2"
----

The key of a label can be subdomain-prefixed:

[source,terminal]
----
labels:
- "konveyor.io/key1=val1"
----

The value of a label can be empty:

[source,terminal]
----
labels:
- "konveyor.io/key="
----

The value of a label can be omitted. In that case, it is treated as an empty value:

[source,terminal]
----
labels:
- "konveyor.io/key"
----

.Reserved labels

The analyzer defines some labels that have special meaning as follows:

* `konveyor.io/source`: Identifies the source technology to which a rule or a ruleset applies

* `konveyor.io/target`: Identifies the target technology to which a rule or a ruleset applies

.Label selector

The analyzer CLI takes the `--label-selector` field as an option. It is a string expression that supports logical AND, OR and NOT operations. You can use it to filter-in or filter-out rules by their labels.

_Examples:_

* To filter-in all rules that have a label with key `konveyor.io/source` and value `eap6`:
+
`--label-selector="konveyor.io/source=eap6"`

* To filter-in all rules that have a label with key `konveyor.io/source` and any value:
+
`--label-selector="konveyor.io/source"`

* To perform logical AND operations on matches of multiple rules using the `&&` operator:
+
`--label-selector="key1=val1 && key2"`

* To perform logical OR operations on matches of multiple rules using the `||` operator:
+
`--label-selector="key1=val1 || key2"`

* To perform a NOT operation to filter-out rules that have `key1=val1` label set using the `!` operator:
+
`--label-selector="!key1=val1"`

* To group sub-expressions and control precedence using AND:
+
`--label-selector="(key1=val1 || key2=val2) && !val3"`

.Dependency labels

The analyzer engine adds labels to dependencies. These labels provide additional information about a dependency such as whether the dependency is open-source or internal, its programming language, etc.

Currenty, the analyzer adds the following labels on dependencies:

[source,terminal]
----
labels:
- konveyor.io/dep-source=internal
- konveyor.io/language=java
----

.Dependency label selector

The analyzer CLI accepts the `--dep-label-selector` option, which allows filtering-in or filtering-out incidents generated from a dependency by their labels.

For example, the analyzer adds a `konveyor.io/dep-source` label to dependencies with a value that indicates whether the dependency is a known open-source dependency.

To exclude incidents for all such open-source dependencies, you can use `--dep-label-selector` as follows:

`konveyor-analyzer ... --dep-label-selector !konveyor.io/dep-source=open-source`

The Java provider in the analyzer can also add an exclude label to a list of packages. To exclude all such packages, you can use `--dep-label-selector` as follows:

`konveyor-analyzer ... --dep-label-selector !konveyor.io/exclude`

[id="yaml-rule-actions_{context}"]
=== Rule Actions

Rules include message and tag actions.

.Message actions

The message action generates a message for every issue created when rule matches. The custom data exported by providers can also be used in the message.

`message: "helpful message about the issue"`

Optionally, a message can include hyperlinks to external URLs that provide relevant information about the issue or a quick fix.

[source,terminal]
----
links:
  - url: "konveyor.io"
    title: "Short title for the link"
----

.Tag actions

The tag action instructs the analyzer to generate tags for the application when a match is found. Each string in the `tag` field can be a comma-separated list of tags. Optionally, you can assign categories to tags.

[source,terminal]
----
tag:
  - "tag1,tag2,tag3"
  - "Category=tag4,tag5"
----

=== Rule conditions

Each rule contains a `when` block. This block specifies a condition that needs to be met for {ProductShortName} to perform a certain action.

The `when` block contains one condition, but that condition can have multiple conditions nested under it.

[source,terminal]
----
when:
  <condition>
    <nested-condition>
----

==== Provider conditions

A provider condition indicates how to analyze the source code of the application. Each provider has a number of "capabilities" that can be used to analyze the code.

The provider condition has the form `<provider_name>.<capability>`:

[source,terminal]
----
when:
  <provider_name>.<capability>
    <input_fields>
----

The analyzer currently supports the following provider conditions:

* `builtin`
* `java`
* `go`

===== `builtin` provider

`builtin` is an internal provider that can analyze various files and internal metadata generated by the engine.

This provider has the following capabilities:

* `file`
* `filecontent`
* `xml`
* `json`
* `hasTags`

.`file`

The `file` capability enables the provider to search for files in the source code that match a given pattern.

[source,terminal]
----
when:
  builtin.file:
    pattern: "<regex_to_match_filenames>"
----

.`filecontent`

The `filecontent` capability enables the provider to search for content that matches a given pattern.

[source,terminal]
----
when:
  builtin.filecontent:
    filePattern: "<regex_to_match_filenames_to_scope_search>"
    pattern: "<regex_to_match_content_in_the_matching_files>"
----

.`xml`

The `xml` capability enables the provider to query XPath expressions on a list of provided XML files. This capability takes 2 input parameters.

[source,terminal]
----
when:
  builtin.xml:
    xpath: "<xpath_expressions>" <1>
    filepaths: <2>
      - "/src/file1.xml"
      - "/src/file2.xml"
----
<1> `xpath` must be a valid xpath expression.
<2> `filepaths` is a list of files to apply the XPath query to.

.`json`

The `json` capability enables the provider to query XPath expressions on a list of provided JSON files. Currently, `json` only takes XPath as input and performs the search on all JSON files in the codebase.

[source,terminal]
----
when:
  builtin.json:
    xpath: "<xpath_expressions>" <1>
----
<1> `xpath` must be a valid xpath expression.

.`hasTags`

The `hasTags` capability enables the provider to query application tags. It queries the internal data structure to check whether the application has the given tags.

[source,terminal]
----
when:
  # when more than one tags are given, a logical AND is implied
  hasTags: <1>
    - "tag1"
    - "tag2"
----
<1> When more than one tags is given, a logical AND is implied.

===== `java` provider

The `java` provider analyzes Java source code.  This provider's capabilities are `referenced` and `dependency`.

.`referenced`

The `referenced` capability enables the provider to find references in the source code. This capability takes two input parameters, `pattern` and `location`.

[source,terminal]
----
when:
  java.referenced:
# regex pattern to match
    pattern: "<pattern>" <1>
# location defines the exact location where
# pattern should be matched
    location: CONTRUCTOR_CALL <2>
----
<1> A regex pattern to match
<2> Specifies the exact location where the pattern needs to be matched

The supported locations are the following:

* `CONSTRUCTOR_CALL`
* `TYPE`
* `INHERITANCE`
* `METHOD_CALL`
* `ANNOTATION`
* `IMPLEMENTS_TYPE`
* `ENUM_CONSTANT`
* `RETURN_TYPE`
* `IMPORT`
* `VARIABLE_DECLARATION`

.`dependency`

Needs info

===== `go` provider

The `go` provider analyzes Golang source code.  This provider's capabilities are `referenced` and `dependency`.

.`referenced`

The `referenced` capability enables the provider to find references in the source code.

[source,terminal]
----
when:
  go.referenced: "<regex_to_find_reference>"
----

.`dependency`

The `dependency` capability  enables the provider to find dependencies for an application.

[source,terminal]
----
when:
  go.dependency:
    name: "<dependency_name>" <1>
    upperbound: "<version_string>" <2>
    lowerbound: "<version_string>" <3>
----
<1> Name of the dependency to search for
<2> Upper bound on the version of the dependency
<3> Lower bound on the version of the dependency

=== Logical conditions

The analyzer provides two basic logical conditions, `and` and `or`, that enable you to aggregate results of other conditions and create more complex queries.

==== `and` condition

The `and` condition performs a logical 'and' operation on the results of an array of conditions.

[source,terminal]
----
when:
  and:
    - <condition1>
    - <condition2>
----

_Example_

[source,terminal]
----
when:
  and:
    - java.dependency:
        name: junit.junit
        upperbound: 4.12.2
        lowerbound: 4.4.0
    - java.dependency:
        name: io.fabric8.kubernetes-client
        lowerbound: 5.0.100
----

Conditions can also be nested within other conditions.

_Example_

[source,terminal]
----
when:
  and:
  - and:
    - go.referenced: "*CustomResourceDefinition*"
    - java.referenced:
        pattern: "*CustomResourceDefinition*"
  - go.referenced: "*CustomResourceDefinition*"
----

==== `or` condition

The `or` condition performs a logical 'or' operation on the results of an array of conditions.

[source,terminal]
----
when:
  or:
    - <condition1>
    - <condition2>
----

== Rulesets

A set of rules forms a ruleset. Rulesets are a way of organizing multiple rules that achieve a common goal and passing the rules to the rules engine.

Each ruleset is stored in its own directory with a `ruleset.yaml` file at the directory root that stores the metadata of the ruleset.

[source,terminal]
----
name: "Name of the ruleset" <1>
description: "Description of the ruleset"
labels: <2>
  - awesome_rules1
----
<1> The name must be unique within the provided rulesets.

<2> Ruleset labels are inherited by all rules that belong to the ruleset.